#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
sequence_preparation.py

This script reads a labeled CSV file (generated by your pipeline) where each row represents a video frame.
Each row includes various landmark values, additional computed features, and a 'stroke_label' column.

It extracts per-frame feature vectors, applies a sliding window to create sequences of a fixed length,
and assigns a sequence-level label of 1 if any frame in the sequence has 'stroke_label' == 1.

Usage (from command line):
    python src/data/sequence_preparation.py --csv_path path/to_labeled_file.csv
                                           --window_size 30
                                           --stride 15
                                           --output_dir output_folder
OR simply:
    python src/data/sequence_preparation.py --window_size 30 --stride 15
(to let the script auto-discover a '*_labeled.csv' file)
"""

import argparse
import os
import sys
import numpy as np
import pandas as pd

def find_labeled_csv(base_dir):
    """
    Searches for any file that ends with '_labeled.csv' inside base_dir (recursively).
    Returns a list of all matching file paths.
    """
    matches = []
    for root, dirs, files in os.walk(base_dir):
        for f in files:
            if f.endswith("_labeled.csv"):
                matches.append(os.path.join(root, f))
    return matches

def prepare_sequences(csv_path, window_size=30, stride=15, feature_columns=None, target_column="stroke_label"):
    """
    Processes the labeled CSV file to generate sequence data.

    Parameters:
        csv_path (str): Path to the labeled CSV file.
        window_size (int): Number of consecutive frames per sequence.
        stride (int): Step size for the sliding window.
        feature_columns (list or None): List of column names to use as features.
                                        If None, all columns except 'frame_index', target_column, and 'swing_phase' are used.
        target_column (str): Column name for the stroke label.

    Returns:
        X (np.array): Array of shape (num_sequences, window_size, num_features) for the sequences.
        y (np.array): Array of shape (num_sequences,) for the sequence-level labels.
    """
    # Load the CSV
    df = pd.read_csv(csv_path)

    # Ensure data is sorted in ascending order of frame_index (if present)
    if "frame_index" in df.columns:
        df = df.sort_values("frame_index").reset_index(drop=True)

    # Decide which columns to use as features
    if feature_columns is None:
        ignore_cols = {"frame_index", target_column, "swing_phase"}
        feature_columns = [col for col in df.columns if col not in ignore_cols]

    # Ensure target column is numeric
    if target_column not in df.columns:
        raise ValueError(f"Target column '{target_column}' not found in the CSV file.")
    df[target_column] = pd.to_numeric(df[target_column], errors="coerce").fillna(0).astype(int)

    # Extract features and target values
    data = df.reset_index(drop=True)
    features = data[feature_columns].values  # shape: (num_frames, num_features)
    targets = data[target_column].values     # shape: (num_frames,)

    X, y = [], []
    num_frames = len(features)

    # Use a sliding window to create sequences
    for i in range(0, num_frames - window_size + 1, stride):
        seq_feat = features[i:i + window_size]
        seq_target = targets[i:i + window_size]

        # If any frame in the window has stroke_label == 1, label the entire sequence as 1
        seq_label = 1 if np.any(seq_target == 1) else 0
        X.append(seq_feat)
        y.append(seq_label)

    return np.array(X), np.array(y)

def main():
    base_dir = os.path.dirname(__file__)
    default_search_dir = os.path.join(base_dir, "..", "..", "data", "processed")

    parser = argparse.ArgumentParser(
        description="Generate sequences from a labeled CSV file for training a sequence model."
    )
    parser.add_argument(
        "--csv_path", type=str, default=None,
        help="Path to the labeled CSV file. If not provided, the script auto-discovers a '*_labeled.csv' inside data/processed/."
    )
    parser.add_argument(
        "--window_size", type=int, default=30,
        help="Number of frames per sequence."
    )
    parser.add_argument(
        "--stride", type=int, default=15,
        help="Stride of the sliding window."
    )
    parser.add_argument(
        "--output_dir", type=str, default=None,
        help="Directory to save the resulting arrays. Defaults to the same directory as the CSV."
    )

    args = parser.parse_args()

    # If the user hasn't specified a CSV file, search for one under data/processed/
    if args.csv_path is None:
        labeled_files = find_labeled_csv(default_search_dir)
        if not labeled_files:
            raise ValueError(f"No labeled CSV found in {default_search_dir}. Please specify --csv_path explicitly.")
        if len(labeled_files) > 1:
            print("Multiple labeled CSV files found; using the first one:")
            print(labeled_files)
        csv_path = labeled_files[0]
        print(f"Using discovered CSV file: {csv_path}")
    else:
        csv_path = args.csv_path

    # If no --output_dir specified, use the CSV's directory
    if args.output_dir is None:
        output_dir = os.path.dirname(csv_path)
    else:
        output_dir = args.output_dir

    # Set file paths for outputs
    seq_file = os.path.join(output_dir, "sequences.npy")
    labels_file = os.path.join(output_dir, "labels.npy")

    # Check if the output already exists, then skip reanalysis
    if os.path.exists(seq_file) and os.path.exists(labels_file):
        print(f"Processed data already exists at {output_dir} for CSV '{os.path.basename(csv_path)}'; skipping sequence generation.")
        sys.exit(0)

    # Prepare sequences
    X, y = prepare_sequences(csv_path, window_size=args.window_size, stride=args.stride)
    print(f"Created {len(X)} sequences from {csv_path}")
    if len(X) > 0:
        print(f"Each sequence has shape: {X[0].shape} (window_size, num_features)")

    # Save the sequences and labels
    os.makedirs(output_dir, exist_ok=True)
    np.save(seq_file, X)
    np.save(labels_file, y)
    print(f"Saved sequences to {seq_file}")
    print(f"Saved labels to {labels_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
print("sequence_preparation.py")